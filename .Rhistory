return(NULL)
}
train_id <- sample(seq_len(n_users), size = round(0.8 * n_users))
train <- bin_mat[train_id, ]
test  <- bin_mat[-train_id, ]
# ---- 6. UBCF модель (Jaccard) ----
# 1. Залишаємо модель для оцінки якості (на 80% даних)
rec_val <- Recommender(train, "UBCF", parameter = list(method = "Jaccard", nn = 50))
# 2. Створюємо фінальну модель для бізнесу (на 100% даних)
# Саме вона дасть найкращі поради, бо знає історію кожного клієнта
rec_final <- Recommender(bin_mat, "UBCF", parameter = list(method = "Jaccard", nn = 50))
top_n <- input$top_n
# ---- 6A. Рекомендації по TEST ----
pred_test <- predict(rec_val, newdata = test, n = top_n, type = "topNList")
rec_list_test <- as(pred_test, "list")
test_ids <- rownames(test)
test_m <- as(test, "matrix")
rec_list_test <- purrr::map2(
.x = rec_list_test,
.y = test_ids,
~{
uid <- .y
bought_items <- colnames(test_m)[test_m[uid, ] > 0]
head(
apply_rules(
recs = .x,
bought_items = bought_items,
never_recommend = never_recommend,
tobacco_cat = tobacco_cat,
alcohol_cats = alcohol_cats,
kids_cat = kids_cat,
kids_signal = kids_signal,
policy = policy
),
top_n
)
}
)
rec_long <- purrr::map2_df(
.x = rec_list_test,
.y = test_ids,
~ tibble::tibble(client_id = .y, category = .x, rank = seq_along(.x))
)
if (nrow(rec_long) == 0) {
showNotification("Модель не згенерувала жодної рекомендації. Перевірте дані.", type = "error")
return(NULL)
}
rec_long <- rec_long %>% mutate(rank_score = top_n - rank + 1)
# ---- 7. ОЦІНКА ЯКОСТІ (тільки в лог/консоль, без UI) ----
hold <- make_holdout_newdata(bin_mat, keep_frac = 0.7, seed = 123)
if (nrow(hold$given_mat) >= 10) {
# 7A) Predictions model (holdout newdata)
pred_hold <- predict(rec_val, newdata = hold$newdata, n = top_n, type = "topNList")
recs_list <- as(pred_hold, "list")
user_ids <- rownames(hold$newdata)
# 7B) Popular baseline: топ популярних категорій з train
train_m <- as(train, "matrix")
pop_counts <- colSums(train_m > 0)
pop_items <- names(sort(pop_counts, decreasing = TRUE))
make_pop_recs <- function(given_row, k) {
already <- names(given_row)[given_row > 0]
cand <- setdiff(pop_items, already)
head(cand, k)
}
# 7C) Random baseline
all_items <- colnames(hold$given_mat)
make_rand_recs <- function(given_row, k) {
already <- names(given_row)[given_row > 0]
cand <- setdiff(all_items, already)
if (length(cand) == 0) return(character(0))
sample(cand, size = min(k, length(cand)))
}
# 7D) Метрики по клієнтах
details <- purrr::map2_df(
.x = user_ids,
.y = seq_along(user_ids),
~{
uid <- .x
i <- .y
given_row <- hold$given_mat[i, ]
truth <- hold$truth[[uid]]
rec_model <- recs_list[[i]]
rec_pop <- make_pop_recs(given_row, top_n)
rec_rand <- make_rand_recs(given_row, top_n)
m1 <- calc_metrics_at_k(rec_model, truth, top_n)
m2 <- calc_metrics_at_k(rec_pop, truth, top_n)
m3 <- calc_metrics_at_k(rec_rand, truth, top_n)
tibble::tibble(
client_id = uid,
truth_size = length(truth),
model_precision = m1$precision,
model_recall    = m1$recall,
model_hit       = m1$hit,
model_map       = m1$ap,
model_ndcg      = m1$ndcg,
pop_precision   = m2$precision,
pop_recall      = m2$recall,
pop_hit         = m2$hit,
pop_map         = m2$ap,
pop_ndcg        = m2$ndcg,
rand_precision  = m3$precision,
rand_recall     = m3$recall,
rand_hit        = m3$hit,
rand_map        = m3$ap,
rand_ndcg       = m3$ndcg
)
}
)
summary_tbl <- tibble::tibble(
Method = c("UBCF model", "Popular baseline", "Random baseline"),
`Precision@K` = c(mean(details$model_precision, na.rm = TRUE),
mean(details$pop_precision,   na.rm = TRUE),
mean(details$rand_precision,  na.rm = TRUE)),
`Recall@K`    = c(mean(details$model_recall, na.rm = TRUE),
mean(details$pop_recall,   na.rm = TRUE),
mean(details$rand_recall,  na.rm = TRUE)),
`HitRate@K`   = c(mean(details$model_hit, na.rm = TRUE),
mean(details$pop_hit,   na.rm = TRUE),
mean(details$rand_hit,  na.rm = TRUE)),
`MAP@K`       = c(mean(details$model_map, na.rm = TRUE),
mean(details$pop_map,   na.rm = TRUE),
mean(details$rand_map,  na.rm = TRUE)),
`nDCG@K`      = c(mean(details$model_ndcg, na.rm = TRUE),
mean(details$pop_ndcg,   na.rm = TRUE),
mean(details$rand_ndcg,  na.rm = TRUE))
) %>%
dplyr::mutate(
`Precision@K` = round(`Precision@K`, 4),
`Recall@K`    = round(`Recall@K`, 4),
`HitRate@K`   = round(`HitRate@K`, 4),
`MAP@K`       = round(`MAP@K`, 4),
`nDCG@K`      = round(`nDCG@K`, 4)
)
# Збережемо в rv (на всяк випадок)
rv$quality_summary <- summary_tbl
rv$quality_details <- details
# Вивід тільки в консоль / логи
message("=== RECSYS QUALITY (Holdout on TEST) ===")
message("K = ", top_n, ", holdout keep_frac = 0.7")
print(summary_tbl)
message("---- details (first 20 rows) ----")
print(head(details, 20))
message("=== END RECSYS QUALITY ===")
} else {
rv$quality_summary <- tibble::tibble(
Message = "Not enough test users with >=2 purchases for holdout evaluation."
)
rv$quality_details <- NULL
message("=== RECSYS QUALITY ===")
message("Not enough test users with >=2 purchases for holdout evaluation.")
message("=== END RECSYS QUALITY ===")
}
# ---- ТОП категорій по TEST (зрозумілий рейтинг для клієнта) ----
n_test_clients <- rec_long %>% dplyr::summarise(n = dplyr::n_distinct(client_id)) %>% dplyr::pull(n)
top_categories_test <- rec_long %>%
dplyr::filter(!is.na(category), category != "", category != "OTHER") %>%
dplyr::group_by(category) %>%
dplyr::summarise(
`Попит за рекомендаціями (індекс)` = sum(rank_score, na.rm = TRUE),
`К-сть клієнтів, кому рекомендовано` = dplyr::n_distinct(client_id),
`Середня сила рекомендації (1–N)` = round(mean(rank_score, na.rm = TRUE), 2),
.groups = "drop"
) %>%
dplyr::mutate(`Охоплення, % клієнтів` = round(100 * `К-сть клієнтів, кому рекомендовано` / n_test_clients, 1)) %>%
dplyr::arrange(dplyr::desc(`Попит за рекомендаціями (індекс)`), dplyr::desc(`К-сть клієнтів, кому рекомендовано`)) %>%
dplyr::slice_head(n = 20)
rv$top_categories_test <- top_categories_test
# ---- 6B. Рекомендації по ВСІХ ----
# Використовуємо фінальну модель на повних даних
# ---- 6B. Рекомендації по ВСІХ ----
pred_all <- predict(rec_final, newdata = bin_mat, n = top_n, type = "topNList")
rec_list_all <- as(pred_all, "list")
all_ids <- rownames(bin_mat)
# матриця покупок для визначення bought_items по кожному клієнту
bin_m <- as(bin_mat, "matrix")
rec_list_all <- purrr::map2(
.x = rec_list_all,
.y = all_ids,
~{
uid <- .y
bought_items <- colnames(bin_m)[bin_m[uid, ] > 0]
out <- apply_rules(
recs = .x,
bought_items = bought_items,
never_recommend = never_recommend,
tobacco_cat = tobacco_cat,
alcohol_cats = alcohol_cats,
kids_cat = kids_cat,
kids_signal = kids_signal,
policy = policy
)
head(out, top_n)
}
)
# важливо: якщо після фільтрації рекомендацій стало менше ніж top_n — це нормально.
# але ти можеш не хотіти "порожніх" клієнтів, тоді:
rec_list_all <- lapply(rec_list_all, function(x) head(x, top_n))
rec_long_all <- purrr::map2_df(
.x = rec_list_all,
.y = all_ids,
~ tibble::tibble(client_id = .y, category = .x, rank = seq_along(.x))
) %>%
mutate(rank_score = top_n - rank + 1)
n_all_clients <- rec_long_all %>% dplyr::summarise(n = dplyr::n_distinct(client_id)) %>% dplyr::pull(n)
top_categories_all <- rec_long_all %>%
dplyr::filter(!is.na(category), category != "", category != "OTHER") %>%
dplyr::group_by(category) %>%
dplyr::summarise(
`Індекс попиту` = sum(rank_score, na.rm = TRUE),
`К-сть клієнтів, кому рекомендовано` = dplyr::n_distinct(client_id),
`Середня сила рекомендації` = round(mean(rank_score, na.rm = TRUE), 2),
.groups = "drop"
) %>%
dplyr::mutate(`Охоплення, % клієнтів` = round(100 * `К-сть клієнтів, кому рекомендовано` / n_all_clients, 1)) %>%
dplyr::arrange(dplyr::desc(`Індекс попиту`), dplyr::desc(`К-сть клієнтів, кому рекомендовано`)) %>%
dplyr::slice_head(n = 20)
rv$top_categories_all <- top_categories_all
# ---- rank_matrix ----
library(Matrix)
rank_tmp <- rec_long_all %>%
transmute(
client_id  = as.character(client_id),
category   = as.character(category),
rank_score = as.numeric(rank_score)
) %>%
filter(!is.na(category), category != "") %>%
distinct(client_id, category, .keep_all = TRUE)
ii <- as.integer(factor(rank_tmp$client_id))
jj <- as.integer(factor(rank_tmp$category))
rank_sparse <- Matrix::sparseMatrix(
i = ii, j = jj, x = rank_tmp$rank_score,
dimnames = list(levels(factor(rank_tmp$client_id)),
levels(factor(rank_tmp$category)))
)
rank_matrix_export <- as.data.frame(as.matrix(rank_sparse)) %>%
tibble::rownames_to_column("client_id")
# ---- purchase_export (всі клієнти у матриці) ----
purchase_export <- purchase_matrix %>% as.data.frame() %>% tibble::rownames_to_column("client_id")
# ---- rec_list_export ----
rec_list_export <- rec_long_all %>% arrange(client_id, rank) %>% select(client_id, category, rank_score)
# ---- combined_export (тільки клієнти з рекомендаціями) ----
# !!! НЕ ЧІПАЮ ЛОГІКУ - як у тебе
recommended_ids <- unique(rec_long_all$client_id)
purchase_matrix_recs <- purchase_matrix[rownames(purchase_matrix) %in% recommended_ids, , drop = FALSE]
purchase_export_recs <- purchase_matrix_recs %>%
as.data.frame() %>%
tibble::rownames_to_column("client_id") %>%
mutate(client_id = as.character(client_id)) %>%
rename_with(~ paste0("buy_", .x), -client_id)
rank_export_recs <- rank_matrix_export %>%
mutate(client_id = as.character(client_id)) %>%
filter(client_id %in% recommended_ids) %>%
rename_with(~ paste0("rec_", .x), -client_id)
combined_export <- purchase_export_recs %>% left_join(rank_export_recs, by = "client_id")
combined_export[is.na(combined_export)] <- 0
# ---- Зберігаємо ----
rv$rank_matrix_export <- rank_matrix_export
rv$purchase_dim <- dim(purchase_matrix)
rv$purchase_export <- purchase_export
rv$rec_list_export <- rec_list_export
rv$combined_export <- combined_export
# >>> NEW: client dropdown options
rv$client_options <- sort(unique(combined_export$client_id))
showNotification("Розрахунок завершено ✅", type = "message")
incProgress(1, detail = "Завершення")
})
shinyjs::hide("calc_status")
enable("run")
})
# ---- OUTPUTS ----
output$top_categories_all <- renderTable({
req(rv$top_categories_all)
rv$top_categories_all
})
output$top_categories_test <- renderTable({
req(rv$top_categories_test)
rv$top_categories_test
})
output$preview <- renderTable({
req(rv$rank_matrix_export)
head(rv$rank_matrix_export)
})
output$summary <- renderPrint({
req(rv$rank_matrix_export, rv$purchase_dim, rv$combined_export)
list(
"Кількість клієнтів у матриці" = rv$purchase_dim[1],
"Кількість категорій у матриці" = rv$purchase_dim[2],
"Клієнтів з рекомендаціями (test)" = length(unique(rv$rank_matrix_export$client_id)),
"Розмір рангової матриці (рядки × стовпці)" = dim(rv$rank_matrix_export),
"Розмір combined (рядки × стовпці)" = dim(rv$combined_export)
)
})
# >>> NEW: KPI cards output
output$kpi_cards <- renderUI({
req(rv$purchase_dim, rv$combined_export, rv$top_categories_test)
n_clients <- rv$purchase_dim[1]
n_cats <- rv$purchase_dim[2]
n_recommended <- nrow(rv$combined_export)
coverage <- round(100 * n_recommended / n_clients, 1)
# середня кількість рекомендацій (по rec_* з >0)
rec_cols <- grep("^rec_", names(rv$combined_export), value = TRUE)
avg_recs <- if (length(rec_cols) > 0) {
mean(rowSums(rv$combined_export[, rec_cols, drop = FALSE] > 0))
} else 0
avg_recs <- round(avg_recs, 2)
div(class = "kpi-row",
div(class = "kpi-card",
div(class="kpi-title", "Клієнтів у моделі"),
div(class="kpi-value", format(n_clients, big.mark=" ")),
div(class="kpi-sub", paste0("Категорій: ", format(n_cats, big.mark=" ")))
),
div(class = "kpi-card",
div(class="kpi-title", "Клієнтів з рекомендаціями"),
div(class="kpi-value", format(n_recommended, big.mark=" ")),
div(class="kpi-sub", paste0("Покриття: ", coverage, "%"))
),
div(class = "kpi-card",
div(class="kpi-title", "Середня к-сть рекомендацій"),
div(class="kpi-value", avg_recs)
),
div(class = "kpi-card",
div(class="kpi-title", "ТОП-1 категорія"),
div(class="kpi-value", rv$top_categories_all$category[1] %||% "-"),
div(class="kpi-sub", "за індексом попиту")
)
)
})
# >>> NEW: per-client view UI + table
output$client_picker_ui <- renderUI({
req(rv$client_options)
selectInput("client_pick", "Оберіть клієнта", choices = rv$client_options, selected = rv$client_options[1])
})
output$client_view <- renderTable({
req(rv$combined_export, input$client_pick)
dfc <- rv$combined_export %>% filter(client_id == input$client_pick)
buy_cols <- names(dfc)[startsWith(names(dfc), "buy_")]
rec_cols <- names(dfc)[startsWith(names(dfc), "rec_")]
bought <- tibble(
type = "Покупки",
category = sub("^buy_", "", buy_cols),
value = as.numeric(dfc[1, buy_cols, drop = TRUE])
) %>% filter(value == 1) %>% select(type, category)
recs <- tibble(
type = "Рекомендації",
category = sub("^rec_", "", rec_cols),
score = as.numeric(dfc[1, rec_cols, drop = TRUE])
) %>% filter(score > 0) %>% arrange(desc(score)) %>% transmute(type, category)
bind_rows(bought, recs)
})
# ---- DOWNLOADS ----
output$download_rank <- downloadHandler(
filename = function() {
base <- if (!is.null(input$file$name)) tools::file_path_sans_ext(input$file$name) else "demo"
paste0("recommendations_rank_matrix_", base, ".xlsx")
},
content = function(file) {
req(rv$rank_matrix_export)
openxlsx::write.xlsx(rv$rank_matrix_export, file)
}
)
output$download_purchase <- downloadHandler(
filename = function() {
base <- if (!is.null(input$file$name)) tools::file_path_sans_ext(input$file$name) else "demo"
paste0("client_category_matrix_", base, ".xlsx")
},
content = function(file) {
req(rv$purchase_export)
openxlsx::write.xlsx(rv$purchase_export, file)
}
)
output$download_rec_list <- downloadHandler(
filename = function() {
base <- if (!is.null(input$file$name)) tools::file_path_sans_ext(input$file$name) else "demo"
paste0("recommendations_list_", base, ".xlsx")
},
content = function(file) {
req(rv$rec_list_export)
openxlsx::write.xlsx(rv$rec_list_export, file)
}
)
output$combined_table <- renderDT({
req(rv$combined_export)
df <- rv$combined_export
selected_cats <- input$buy_multi_filter
mode <- input$buy_multi_mode %||% "AND"
if (!is.null(selected_cats) && length(selected_cats) > 0) {
cols <- paste0("buy_", selected_cats)
cols <- cols[cols %in% names(df)]  # безпека
if (length(cols) > 0) {
mat <- as.matrix(df[, cols, drop = FALSE])
keep <- if (mode == "AND") {
rowSums(mat == 1) == ncol(mat)   # усі обрані = 1
} else {
rowSums(mat == 1) >= 1           # хоча б одна = 1
}
df <- df[keep, , drop = FALSE]
}
}
buy_idx <- which(startsWith(names(df), "buy_"))
rec_idx <- which(startsWith(names(df), "rec_"))
client_idx <- which(names(df) == "client_id")
dt <- DT::datatable(
df,
rownames = FALSE,
extensions = c("Scroller"),
options = list(
scrollX = TRUE,
scrollY = 520,
scroller = TRUE,
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Blfrtip"
)
)
# базове оформлення: покупки vs рекомендації
if (length(buy_idx) > 0) {
dt <- DT::formatStyle(
dt,
columns = buy_idx,
backgroundColor = "#D9EEF9"  # як у твоєму Excel для buy_
)
}
if (length(rec_idx) > 0) {
dt <- DT::formatStyle(
dt,
columns = rec_idx,
backgroundColor = "#F1D7F1"  # як у твоєму Excel для rec_
)
}
# виділяємо client_id
if (length(client_idx) > 0) {
dt <- DT::formatStyle(
dt,
columns = client_idx,
fontWeight = "700",
backgroundColor = "#FFFFFF"
)
}
dt
})
# !!! download_combined — залишив твою логіку і форматування
output$download_combined <- downloadHandler(
filename = function() {
base <- if (!is.null(input$file$name)) tools::file_path_sans_ext(input$file$name) else "demo"
paste0("combined_purchases_and_recs_", base, ".xlsx")
},
content = function(file) {
req(rv$combined_export)
df_out <- rv$combined_export
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, "data")
openxlsx::writeData(wb, "data", df_out)
openxlsx::addWorksheet(wb, "read_me")
readme_text <- c(
"Як читати файл",
"",
"1) Колонки buy_* (покупки):",
" • 1 — клієнт купував категорію",
" • 0 — клієнт не купував категорію",
"",
"2) Колонки rec_* (рекомендації):",
" • число > 0 — категорія рекомендована (чим більше, тим сильніша рекомендація)",
" • 0 — категорія не рекомендована",
"",
"Примітка:",
"Файл містить лише клієнтів, для яких модель згенерувала рекомендації."
)
openxlsx::writeData(wb, "read_me", data.frame(text = readme_text), colNames = FALSE)
header_style <- openxlsx::createStyle(
textDecoration = "bold",
fgFill = "#1B065E",
fontColour = "#FFFFFF",
halign = "center",
valign = "center",
border = "Bottom"
)
openxlsx::addStyle(
wb, "data", style = header_style,
rows = 1, cols = 1:ncol(df_out),
gridExpand = TRUE, stack = TRUE
)
buy_cols <- which(startsWith(names(df_out), "buy_"))
rec_cols <- which(startsWith(names(df_out), "rec_"))
buy_style <- openxlsx::createStyle(fgFill = "#D9EEF9")
rec_style <- openxlsx::createStyle(fgFill = "#F1D7F1")
if (length(buy_cols) > 0) {
openxlsx::addStyle(
wb, "data", style = buy_style,
rows = 2:(nrow(df_out) + 1), cols = buy_cols,
gridExpand = TRUE, stack = TRUE
)
}
if (length(rec_cols) > 0) {
openxlsx::addStyle(
wb, "data", style = rec_style,
rows = 2:(nrow(df_out) + 1), cols = rec_cols,
gridExpand = TRUE, stack = TRUE
)
}
openxlsx::freezePane(wb, "data", firstRow = TRUE)
openxlsx::setColWidths(wb, "data", cols = 1:ncol(df_out), widths = "auto")
openxlsx::setColWidths(wb, "read_me", cols = 1, widths = 70)
openxlsx::saveWorkbook(wb, file, overwrite = TRUE)
}
)
}
# helper for UI (safe null)
`%||%` <- function(x, y) if (is.null(x) || length(x) == 0 || is.na(x)) y else x
# ---- Запуск додатку ----
shinyApp(ui, server)
shiny::runApp()
rsconnect::writeManifest()
